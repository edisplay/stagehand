---
title: Caching Actions
description: Cache actions automatically to reduce costs and improve performance
---

import { V3Banner } from '/snippets/v3-banner.mdx';

<V3Banner />

Stagehand supports two caching strategies: server-side caching managed by Browserbase, and local file-based caching.

---

## Server-side Caching

<Note>
  Server-side caching only works when running with `env: "BROWSERBASE"`. It has no effect in local environments.
</Note>

When running on Browserbase, Stagehand automatically caches `act()`, `extract()`, and `observe()` results on the server. Repeated calls with the same inputs return instantly without consuming LLM tokens. Check out the [Browserbase blog](https://www.browserbase.com/blog/stagehand-caching) for more details on how it works under the hood.

### How It Works

- **Enabled by default** — no configuration needed to start benefiting
- **Keyed on inputs** — the instruction, page content, and options are used to generate a cache key
- **Zero token cost on hits** — cached responses bypass the LLM entirely
- **`cacheStatus`** — every `act()` and `extract()` result includes a `cacheStatus` field (`"HIT"` or `"MISS"`) so you can observe cache behavior

### Disabling on the Constructor

Pass `serverCache: false` to disable caching for all requests made by that instance:

```typescript
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  serverCache: false,
});

await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://example.com");

// Cache is disabled — always hits the LLM
await stagehand.act("click the login button");
```

### Disabling per Call

Override the instance setting for a single call by passing `serverCache: false` in the options:

```typescript
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({ env: "BROWSERBASE" }); // caching on by default

await stagehand.init();
const page = stagehand.context.pages()[0];
await page.goto("https://example.com");

// This call skips the cache
await stagehand.act("click the login button", { serverCache: false });

// These calls use the cache as normal
await stagehand.extract("extract the page title");
await stagehand.observe("find the nav links");
```

### Inspecting Cache Status

Both `act()` and `extract()` return a `cacheStatus` field you can use to verify whether a result was served from cache:

```typescript
const actResult = await stagehand.act("click the login button");
console.log(actResult.cacheStatus); // "HIT" or "MISS"
```

<Note>
  `observe()` does not currently expose a `cacheStatus` field. To check whether an `observe()` call was served from cache, use the [Browserbase session replay dashboard](https://docs.browserbase.com/features/observability#stagehand) or inspect the session logs.
</Note>

### Limitations

- Server-side caching does **not** apply to `agent()` at the moment. Use local caching (below) if you need caching for agent workflows.
- The page URL factors in to the cache key. If the action is being made on a page with a dynamic URL, caching may not work as expected. We do filter out certain query parameters like referral trackers and analytics, but we don't catch everything just yet.
- If the page content or structure changes, the action won't get a cache `HIT` and the LLM will be called. The subsequent actions will attempt to hit the resulting cache entry.

---

## Local Caching

Local caching writes results to your filesystem using a `cacheDir`. It works in both `LOCAL` and `BROWSERBASE` environments and is useful for `act()` and `agent()` workflows where you want caching to persist across machines or CI runs.

### How It Works

When you specify a `cacheDir`:
1. **First run**: Actions use LLM inference and results are cached to a local file
2. **Subsequent runs**: Cached actions are reused automatically (no LLM calls)
3. **Cost savings**: Eliminate redundant inference calls for repeated actions
4. **Performance**: Faster execution by skipping LLM inference

### Caching with `act()`

Cache actions from `act()` by specifying a cache directory in your Stagehand constructor.

```typescript
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "act-cache", // Specify a cache directory
});

await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://browserbase.github.io/stagehand-eval-sites/sites/iframe-same-proc-scroll/");

// First run: uses LLM inference and caches
// Subsequent runs: reuses cached action
await stagehand.act("scroll to the bottom of the iframe");

// Variables work with caching too
await stagehand.act("fill the username field with %username%", {
  variables: {
    username: "fakeUsername",
  },
});
```

### Caching with `agent()`

Cache agent actions (including Computer Use Agent actions) the same way - just specify a `cacheDir`. The cache key is automatically generated based on the instruction, start URL, agent execution options, and agent configuration - subsequent runs with the same parameters will reuse cached actions.

```typescript
import { Stagehand } from "@browserbasehq/stagehand";

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "agent-cache", // Specify a cache directory
});

await stagehand.init();
const page = stagehand.context.pages()[0];

await page.goto("https://browserbase.github.io/stagehand-eval-sites/sites/drag-drop/");

const agent = stagehand.agent({
  mode: "cua",
  model: {
    modelName: "google/gemini-2.5-computer-use-preview-10-2025",
    apiKey: process.env.GOOGLE_GENERATIVE_AI_API_KEY
  },
  systemPrompt: "You are a helpful assistant that can use a web browser.",
});

await page.goto("https://play2048.co/");

// First run: uses LLM inference and caches
// Subsequent runs: reuses cached actions
const result = await agent.execute({
  instruction: "play a game of 2048",
  maxSteps: 20,
});

console.log(JSON.stringify(result, null, 2));
```

### Cache Directory Organization

You can organize your caches by using different directory names for different workflows:

```typescript
// Separate caches for different parts of your automation
const loginStagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/login-flow"
});

const checkoutStagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/checkout-flow"
});

const dataExtractionStagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/data-extraction"
});
```

### Best Practices

<AccordionGroup>

<Accordion title="Use descriptive cache directories">
Organize caches by workflow or feature for easier management:

```typescript
// Good: descriptive cache names
cacheDir: "cache/login-actions"
cacheDir: "cache/search-actions"
cacheDir: "cache/form-submissions"

// Avoid: generic cache names
cacheDir: "cache"
cacheDir: "my-cache"
```
</Accordion>

<Accordion title="Clear cache when DOM changes">
If the website structure changes significantly, clear your cache directory to force fresh inference:

```bash
rm -rf cache/login-actions
```

Or programmatically:

```typescript
import { rmSync } from 'fs';

// Clear cache before running if needed
if (shouldClearCache) {
  rmSync('cache/login-actions', { recursive: true, force: true });
}

const stagehand = new Stagehand({
  env: "BROWSERBASE",
  cacheDir: "cache/login-actions"
});
```
</Accordion>

<Accordion title="Commit cache for CI/CD">
Consider committing your cache directory to version control for consistent behavior across environments:

```gitignore
# .gitignore
# Don't ignore cache directories
!cache/
```

This ensures your CI/CD pipelines use the same cached actions without needing to run inference on first execution.
</Accordion>

</AccordionGroup>
